.386                ;use the 386 instruction set.
.model flat,stdcall ;This is the calling convention used by the compiler.
option casemap:none ;This is to make sure that the compiler doesn't change the case of the function names.
.data   ;This is where the data is stored.
    msg db 'Hello World!',0 ;This is the message that will be displayed.
.code   ; This is where the code is stored.
main proc   ;This is the main procedure.
    mov ebp,esp ;This is to set the base pointer to the stack pointer.
    sub esp , 10h   ;This is to allocate 16 bytes of memory on the stack to store handle and GetProcAddress.
    call prepare    ;This is to call the prepare procedure.
    mov [ebp - 8], edx ; After the call to prepare, the edx register contains the address of the GetProcAddress function
                       ; the ebx register contains the kernel32 base address. we store the address of GetProcAddress in stack to use later.
    push 0        ; 0
    push 656c646eh ; "ndle"
    push 61486474h ; "tdHa"
    push 53746547h ; "GetS"
    push esp        ; "GetStdHandle\0"
    push ebx        ; Kernel32 base address
    call edx        ; call GetProcAddress(GetStdHandle) to get the address of GetStdHandle, the result is stored in eax.
    push -11        ; STD_OUTPUT_HANDLE
    call eax        ; call GetStdHandle(STD_OUTPUT_HANDLE) to get the handle of the standard output. the result is stored in eax.
    mov [ebp - 4], eax ; Save handle to stack
    xor eax, eax    ; clear eax
    push 00000041h ; A
    push 656c6f73h ; "sole"
    push 6e6f4365h ; "eCon"
    push 74697257h ; "Writ"
    push esp        ; "WriteConsoleA\0"
    push ebx        ; Kernel32 base address
    mov edx, [ebp - 8]  ; Get the address of GetProcAddress from stack
    call edx        ; GetProcAddress(WriteConsoleA) to get the address of WriteConsoleA, the result is stored in eax.
    push 0          ; NULL
    push 13         ; Length of string
    push offset msg ; String
    push [ebp - 4]  ; Handle
    call eax        ; WriteConsoleA(Handle, String, Length of string, NULL)
    xor eax, eax    ; clear eax
    push 00737365h ; "ess\0"
    push 636f7250h ; "Proc"
    push 74697845h ; "Exit"
    push esp        ; "ExitProcess\0"
    push ebx        ; Kernel32 base address
    mov edx, [ebp - 8]  ; Get the address of GetProcAddress from stack
    call edx        ; GetProcAddress(ExitProcess) to get the address of ExitProcess, the result is stored in eax.
    push 0          ; Exit code
    call eax        ; ExitProcess(0)
main endp
prepare proc    ;   this is what prepare proc do
                ;  1. get the base address of kernel32.dll through PEB structure stored in fs:[30h]
                ;  2. find export table address
                ;  3. find the address of GetProcAddress function in export table
                ;  through the address of GetProcAddress function, we can get the address of any function in kernel32.dll
                ;  the address of GetProcAddress function is stored in edx, the kernel32.dll base address is stored in ebx
findKernel32Base:
    xor ecx, ecx
    ASSUME FS:NOTHING
    mov eax, fs:[ecx + 30h]  ; EAX = PEB
    mov eax, [eax + 0ch]      ; EAX = PEB->Ldr
    mov esi, [eax + 14h]     ; ESI = PEB->Ldr.InMemOrder
    lodsd                     ; EAX = Second module
    xchg eax, esi             ; EAX = ESI, ESI = EAX
    lodsd                     ; EAX = Third(kernel32)
    mov ebx, [eax + 10h]     ; EBX = Base address
findExportTable:
    mov edx, [ebx + 3ch] ; EDX = DOS->e_lfanew
    add edx, ebx          ; EDX = PE Header
    mov edx, [edx + 78h] ; EDX = Offset export table
    add edx, ebx          ; EDX = Export table
    mov esi, [edx + 20h] ; ESI = Offset names table
    add esi, ebx          ; ESI = Names table
    xor ecx, ecx          ; EXC = 0
findGetProc:
    inc ecx                              ; Increment the ordinal
    lodsd                                ; Get name offset
    add eax, ebx                         ; Get function name
    cmp dword ptr[eax], 50746547h       ; GetP
    jnz findGetProc
    cmp dword ptr[eax + 4h], 41636f72h ; rocA
    jnz findGetProc
    cmp dword ptr[eax + 8h], 65726464h ; ddre
    jnz findGetProc
findGetProcAddr:
    mov esi, [edx + 24h]    ; ESI = Offset ordinals
    add esi, ebx             ; ESI = Ordinals table
    mov cx, [esi + ecx * 2]  ; CX = Number of function
    dec ecx
    mov esi, [edx + 1ch]    ; ESI = Offset address table
    add esi, ebx             ; ESI = Address table
    mov edx, [esi + ecx * 4] ; EDX = Pointer(offset)
    add edx, ebx             ; EDX = GetProcAddress
    ret
prepare endp
end main