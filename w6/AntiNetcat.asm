section .rodata
msg         db "Finding netcat processes to kill: ", 0Ah, 0
procpath    db "/proc", 0
sttstr       db "/status", 0
ncproc      db "nc", 0
ncatproc    db "ncat", 0
socatproc   db "socat", 0

section .data
    sttdir  db '/proc/', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ;append 20 bytes

section .bss
    buffer  resb 1024
    sttbuf  resb 50
    fd      resd 1
    sttfd   resd 1
    nread   resd 1
    pid     resd 1   
    bpos    resd 1
    dirent  resq 1
    timer   resb 32     ;struct timer
    act     resb 152    ;struct sigaction

section .text
global _start
_start: 
    mov rbp, rsp
    call sigact
     
    ;setup singal handler
    mov qword [act], sigact         ;-> sa_handler
    mov qword [act + 8], 40000000h  ;-> sa_flags
    mov dword [act + 10h], restore  ;-> restore
    mov rdi, 14
    mov rsi, act
    mov rdx, 0
    mov r10d, 8
    mov rax, 13
    syscall             ;rt_sigaction(SIGALRM, &act, NULL, 8)

    cmp rax, 0
    jnz .failedExit     ;if failed

    ;set timer
    mov dword [timer + 10h], 10  ;10 seconds
    mov rax, qword [timer + 10h]
    mov qword [timer], rax      ;timer.it_interval = timer.it_value
    mov rdi, 0
    mov rsi, timer 
    mov rdx, 0
    mov rax, 38
    syscall         ;settimer(ITIMER_REAL, &timer, NULL)

    .endlessLoop:
    jmp .endlessLoop

;exit
    mov rdi, 0
    mov rax, 60
    syscall

    .failedExit:
    mov rdi, -1
    mov rax, 60
    syscall

sigact:
    push rbp
    mov rbp, rsp
    push rbx
    sub rsp, 10fh
    ;open /proc as directory with readonly privilege
    mov rdi, procpath
    mov rsi, 10000h
    mov rdx, 0
    mov rax, 2
    syscall         ;open("/proc",O_DIRECTORY | O_RDONLY)

    cmp eax, -1
    jnz .beginKill
    mov rdx, -1
    mov rax, 60
    syscall         ;exit(-1)

    .beginKill:
    mov [rbp -4], eax
    ;write promp infor
    mov rdi, 1
    mov rsi, msg
    mov rdx, 36
    mov rax, 1
    syscall

    .readProcess:
    mov edi, [rbp - 4]
    mov rsi, buffer
    mov rdx, 1024
    mov rax, 78
    syscall         ;getdents(fd, buffer, 1024)

    cmp eax, 0
    jnz .retProc

    mov ecx, 0
    mov [rbp - 0ch], ecx
    mov [rbp - 8], eax

    .iterProcess:
    mov ecx, [rbp - 0ch]
    cmp ecx, [rbp - 8]
    jge .readProcess
    mov ebx, ecx
    add rbx, buffer         ;rbx = (struct dirent) (buffer + ecx)
    movzx eax, word [rbx + 10h] ;eax = [rbx -> d_reclen]
    add ecx, eax            ;ecx += [rbx -> d_reclen] next process
    mov rdx, rbx
    add rdx, 12h            ;rdx = &d_name
    mov rdi, rdx
    call strlencalc
    mov ecx, eax
    mov rsi, rdx
    mov rdi, sttdir
    add rdi, 6          ;rdi point to after '/' in '/proc/'
    rep movsb

    ;append '/status' to "/proc/<pid>"
    mov ecx, 8
    mov rsi, sttstr
    rep movsb

    ;open status file
    mov rdi, sttdir
    mov rsi, 0      ;O_RDONLY
    mov rdx, 0
    mov rax, 2
    syscall         ;open(sttdir, O_RDONLY)

    cmp eax, -1
    jz .iterProcess     ;if can't open, check next process

    mov rdi, rax
    mov rsi, sttbuf
    mov rdx, 50
    mov rax, 0
    syscall         ;read(sttfd, sttbuf, 50) read character from status file to statusbuf

    ;check if it's netcat process
    ;== 'nc'
    mov rdi, sttbuf
    add rdi, 6          ;point to after "Name: "
    mov rsi, ncproc
    mov rdx, 2
    call strncmp
    cmp eax, 0
    jz .killProc
    ;== 'ncat'
    mov rdi, sttbuf
    add rdi, 6          ;point to after "Name: "
    mov rsi, ncatproc
    mov rdx, 4
    call strncmp
    cmp eax, 0
    jz .killProc

    ;== 'socat'
    mov rdi, sttbuf
    add rdi, 6          
    mov rsi, socatproc
    mov rdx, 5
    call strncmp
    cmp eax, 0
    jz .killProc
    jmp .iterProcess

    .killProc:
    ;write name of peocess about to kill
    mov rdi, rbx
    add rdi, 12h            ; ->d_name
    call strlencalc
    mov rdx, rax
    mov rdi, 1
    mov rsi, rbx
    add rsi, 12h            ; ->d_name
    call println
    ;kill it
    mov rdi, [rbp - 10h]
    mov rsi, 9
    mov rax, 62
    syscall         ;kill(pid, 9)
    jmp .iterProcess

    .retProc:
    add rsp, 10h 
    pop rbx
    mov rsp, rbp
    pop rbp
    ret

restore: 
    mov rax, 15
    syscall





;work similar to strncmp() in C
strncmp:           
    push rbp
    mov rbp, rsp

    cld
    mov rcx, rdx
    .iter:
    lodsb
    mov dl, byte [rdi]
    cmp al, dl
    jnz .exit
    inc rdi
    dec cx
    jnz .iter

    .equal:
    mov rax, 0
    pop rdi
    pop rsi
    mov rsp, rbp
    pop rbp
    ret

    .exit:
    mov rax, rcx
    mov rsp, rbp
    pop rbp
    ret
;calculate strlen(&rdi), return in rax
    strlencalc:     
    push rbp
    mov rbp, rsp
    mov rax, 0
    
    .iter:
    cmp byte [rdi], 0xa
    jz .finished
    cmp byte [rdi], 0
    jz .finished
    inc rdi
    inc rax
    jmp .iter
    
    .finished:
    mov rsp, rbp
    pop rbp
    ret

;print with linefeed by append linefeed to string    
println:    
    mov al, 0xa
    mov [rsi + rdx], al
    inc rdx
    mov rax, 1
    syscall
    ret