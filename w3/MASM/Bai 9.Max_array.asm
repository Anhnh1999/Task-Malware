include C:\masm32\include\masm32rt.inc

NULL equ 0

.data
    stdInHandle HANDLE ?
    stdOutHandle HANDLE ?

    msg byte "nhap so luong phan tu: ",0
    msg1 byte "nhap mang: ",0
    msg2 byte "phan tu lon nhat la: ",0
    arr dword 100 dup(?),0
    inp dword ?
.code

main proc
    call taoHandle

    push offset msg
    call WriteString
    push 100
    push offset inp
    call ReadString
    push offset inp
    call ConvertToNumber
    
    push offset msg1
    call WriteString
    
    push edx
    call InArray

    push offset msg2
    call WriteString
    push edx
    call FindMax
    push eax
    call WriteNumber


    ;exit
    
    push 0
    call ExitProcess
main endp
    
;--------------------------------------
;tao I/O handle
;Return: no return

taoHandle proc
    push STD_INPUT_HANDLE
    call GetStdHandle
    mov stdInHandle, eax
    push STD_OUTPUT_HANDLE
    call GetStdHandle
    mov stdOutHandle, eax
    ret   
taoHandle endp

;------------------------------------------------
; StrLength
; Argument: offset string
; Return: eax = length string
StrLength proc
    push ebp
    mov ebp,esp
    push edi

    mov edi, dword ptr [ebp+8]
    mov eax,0
L1:
    cmp byte ptr [edi],0
    je L2
    inc edi
    inc eax
    jmp L1
L2:
    pop edi
    pop ebp
    ret 4
StrLength endp



;------------------------------------------------
; WriteString
; Argument: offset string
; Return: no return

WriteString proc
    push ebp
    mov ebp,esp
    sub esp,4
    pushad
    ;lay do dai
    push dword ptr [ebp+8]
    call StrLength

    push NULL
    lea ebx, dword ptr [ebp-4]
    push ebx
    push eax
    push dword ptr [ebp+8]
    push stdOutHandle
    call WriteConsole
    popad
    add esp,4
    pop ebp
    ret 4
WriteString endp

;------------------------------------------------
; ReadString
; Argument: Offset string , do dai
; Return: no return

ReadString proc 
	push ebp
	mov ebp,esp
	sub esp,4 
	pushad 

	push NULL					
	lea ebx,dword ptr [ebp - 4]	
	push ebx 					
	push dword ptr [ebp + 12]	 
	push dword ptr [ebp + 8]	
	push stdInHandle 			
	call ReadConsole 

	;tim xuong dong (0Dh) va go no 
	mov edi,dword ptr [ebp + 8]
	mov ecx,dword ptr [ebp + 12] 
	cld 						 
	mov al,0Dh 
	repne scasb 
	jne L2 						  
	dec edi 
	jmp L3 
L2:
	mov edi, dword ptr [ebp + 8]
	add edi, dword ptr [ebp + 12] 
L3:	mov byte ptr [edi],0 		
	
	popad 
	add esp,4
	pop ebp 
	ret 8
ReadString endp


;----------------------------------------------
;InArray
;Agument: so luong phan tu
;No Return

InArray proc
    push ebp
    mov ebp,esp
    pushad
    mov ecx, dword ptr [ebp+8]      ;so luong phan tu
    mov esi, offset arr
L1:
    cmp ecx,0
    je L2 
    push 100
    push esi
    call ReadString
    push esi
    call ConvertToNumber
    mov [esi], edx
    add esi,4
    dec ecx
    jmp L1

L2:
    popad
    pop ebp
    ret 4
InArray endp

;----------------------------------------------
;ConvertToNumber
;Agument: offset 
;Return: edx = number

ConvertToNumber proc
    push ebp
    mov ebp,esp
    push eax
    push esi
    push ecx

    push dword ptr [ebp+8]
    call StrLength
    mov ecx,eax
    mov esi, dword ptr [ebp+8]

    cld
    xor edx,edx
    xor eax,eax

cong:
    imul edx,10
    lodsb
    sub al,48
    add edx,eax
    loop cong

    pop ecx
    pop esi
    pop eax
    pop ebp
    ret 4
ConvertToNumber endp



;------------------------------------------
; WriteNumber
; Argument: number
; No Return
WriteNumber proc 
.data
	temp_buffer byte 10 dup(0),0 
.code 
	push ebp
	mov ebp,esp 
	pushad 

	mov ecx,0
	mov edi,offset temp_buffer 
	add edi,9
	mov ebx,10
	mov eax,dword ptr [ebp + 8]

L1:	
	mov edx,0
	div ebx 
	or dl,30h
	mov [edi],dl 
	dec edi 
	or eax,eax 		; CF = ?

	jnz L1 

	inc edi 
	push edi 
	call WriteString 	

	popad 
	pop ebp 
	ret 4
WriteNumber endp 


;------------------------------------------
; FindMax
; Argument: so luong phan tu
; Return: eax = max

FindMax proc
    push ebp
    mov ebp,esp
    push ecx
    push esi
    mov esi, offset arr
    mov ecx, dword ptr [ebp+8]
    mov eax, arr
L1:
    cmp ecx,0
    je L2
    cmp eax, [esi]
    jle L3
    dec ecx
    add esi,4
    jmp L1
L3:
    mov eax, [esi]
    add esi,4
    dec ecx
    jmp L1

L2:
    pop esi
    pop ecx
    pop ebp
    ret 4
FindMax endp
end main