%include 'function_x64.asm'
section .data
    msg1 db 'Nhap kich thuoc cua mang n: ',0x0
    msg1_len equ $-msg1
    msg2 db 'Nhap mang: ', 0x0
    msg2_len equ $-msg2
    msg3 db 'Max: ',0x0
    msg3_len equ $-msg3
    msg4 db 'Min: ', 0x0
    msg4_len equ $-msg4

section .bss
    buffer resb 10000
    arrN resd 255
    size_arr resd 1
    min resd 1
    max resd 1

section .text
    global _start
    _start:
        mov rbp, rsp
        sub rsp, 8
        
        ;print msg1: 'Nhap kich thuoc cua mang n: '
        mov rdi,1 
        mov rsi, msg1
        mov rdx, msg1_len
        mov rax, 1
        syscall
        ;get size of array
        mov rdi, 0 
        mov rsi, buffer
        mov rdx, 10
        mov rax, 0
        syscall
        mov rdi, buffer
        call atoi
        mov [size_arr], eax

        ;print msg2: 'Nhap mang: '
        mov rdi, 1
        mov rsi, msg2 
        mov rdx, msg2_len
        mov rax, 1
        syscall
        xor rbx, rbx
        
        ;get element until receives n elements
           
        .readArr:     
            mov rdi, 0      
            mov rsi, buffer
            mov rdx, 10000
            mov rax, 0
            syscall
            mov rdi, buffer
            mov r12, arrN
        
        .getElement:
            push rdi
            call atoi
            mov [r12 + rbx*4], eax
            inc ebx
            cmp [size_arr], ebx
            je .doneGetArray
            pop rdi
        .filter:
            cmp byte [rdi], 0xa
            jz .readArr
            inc rdi 

            cmp byte [rdi - 1], 0x20 
            je .getElement
            jmp .filter
        .doneGetArray:
            add rsp, 8
            mov rdi, arrN
            mov esi,[size_arr]
            mov rdx, min
            call findMin
            mov rdi, arrN
            mov esi, [size_arr]
            mov rdx, max
            call findMax

        ;print Min
            mov rdi, 1
            mov rsi, msg4
            mov rdx, msg4_len
            mov rax, 1
            syscall
            mov edi,[min]
            call itoa
            mov rdi,1
            mov rdx, rax
            call println 
        ;print Max
            mov rdi, 1
            mov rsi,msg3
            mov rdx, msg3_len
            mov rax, 1
            syscall
            mov edi, [max]
            call itoa
            mov rdi, 1
            mov rdx, rax
            call println

            mov rdi, 0
            mov rax, 60 
            syscall

        findMin:
            push rbp
            mov rbp, rsp
            push rbx
            mov r8d, 0ffffffffh
            xor rbx, rbx
            .compareMin:
                cmp [rdi], r8d   ; <min
                jb .isMin
            .iterate_Min:
                add rdi, 4
                inc ebx
                cmp ebx, esi
                je .finish_Min
                jmp .compareMin
            .isMin:
                mov r8d, [rdi]  ;min = arrN[i]
                jmp .iterate_Min
            .finish_Min:
                mov dword [rdx], r8d
                pop rbx
                mov rsp, rbp
                pop rbp
                ret
        findMax:
            push rbp
            mov rbp, rsp
            push rbx
            mov r8d,0
            xor rbx, rbx
            
            .compareMax:
                cmp [rdi], r8d  ; >max
                ja .isMax
            .iterate_Max:
                add rdi, 4
                inc ebx
                cmp ebx, esi
                je .finish_Max
                jmp .compareMax
            .isMax:
                mov r8d, [rdi]  ;max = arrN[i]
                jmp .iterate_Max
            .finish_Max:
                mov dword [rdx], r8d
                pop rbx
                mov rsp, rbp
                pop rbp
                ret




            

            

        





